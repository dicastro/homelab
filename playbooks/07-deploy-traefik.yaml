---
- name: Deploy Traefik to Portainer
  hosts: management
  gather_facts: false
  become: no
  vars:
    service_name: "traefik"
    destination_host: "routing"
    certificate_tools_path: "{{ output_path }}/{{ cluster_name }}"
    portainer_api_url: "http://localhost:9000/api"
    portainer_api_url_remote: "http://{{ hostvars[inventory_hostname].ansible_host }}:9000/api"
    portainer_destination_endpoint: "{{ destination_host }}"
    portainer_stack_name: "{{ service_name }}"
    docker_compose_template: "traefik/traefik-compose.yaml.j2"
    docker_compose_output: "{{ output_path }}/{{ cluster_name }}/docker-compose/traefik-compose.yaml"
    traefik_config_template: "traefik/traefik.yaml.j2"
    traefik_config_output: "{{ output_path }}/{{ cluster_name }}/configs/traefik/traefik.yaml"
    traefik_container_user: "traefik"
    traefik_storage_base_dir: "/storage/traefik"
    traefik_config_dir: "{{ traefik_storage_base_dir }}/config"
    traefik_config_file: "{{ traefik_config_dir }}/traefik.yaml"
    traefik_certs_dir: "{{ traefik_storage_base_dir }}/certs"
    traefik_acme_dir: "{{ traefik_storage_base_dir }}/acme"
    traefik_dynamic_dir: "{{ traefik_storage_base_dir }}/dynamic"
    traefik_volumes:
      - "{{ traefik_config_file }}:/traefik.yaml:ro"
      - "{{ traefik_certs_dir }}:/certs"
      - "{{ traefik_acme_dir }}:/acme"
      - "{{ traefik_dynamic_dir }}:/dynamic"
  vars_files:
    - vars/common.yaml
    - "{{ inventory_dir }}/docker-images.yaml"
    - "{{ inventory_dir }}/secrets.yaml"

  tasks:
    - name: Wait for Portainer API to be ready
      ansible.builtin.uri:
        url: "http://localhost:9000/api/status"
        method: GET
        return_content: yes
        status_code: 200
      register: portainer_status
      until: portainer_status.status == 200
      retries: 10
      delay: 5

    - name: Obtain Portainer API token
      ansible.builtin.uri:
        url: "{{ portainer_api_url }}/auth"
        method: POST
        body_format: json
        body:
          username: "{{ portainer_admin_user }}"
          password: "{{ portainer_admin_password }}"
        headers:
          Content-Type: "application/json"
        status_code: 200
      register: portainer_auth

    - name: Set API token as a fact
      ansible.builtin.set_fact:
        portainer_api_token: "{{ portainer_auth.json.jwt }}"

    - name: Get existing Portainer endpoints
      ansible.builtin.uri:
        url: "{{ portainer_api_url }}/endpoints"
        method: GET
        headers:
          Authorization: "Bearer {{ portainer_api_token }}"
        return_content: true
      register: existing_endpoints

    - name: Parse existing endpoints
      ansible.builtin.set_fact:
        existing_endpoints_map: "{{ existing_endpoints.json | items2dict(key_name='Name', value_name='Id') }}"

    - name: Existing endpoints
      ansible.builtin.debug:
        var: existing_endpoints_map

    - name: Set endpoint ID from name
      ansible.builtin.set_fact:
        endpoint_id: "{{ existing_endpoints_map[portainer_destination_endpoint] }}"

    - name: Endpoint selected
      ansible.builtin.debug:
        var: endpoint_id

    - name: Ensure required directories exist on the destination host
      ansible.builtin.file:
        path: "{{ item.split(':')[0] }}"
        state: directory
        mode: "0700"
      loop: "{{ mailrise_volumes }}"
      delegate_to: "{{ destination_host }}"
      when: item.split(':')[0] is string and item.split(':')[0] == item.split(':')[0] | dirname

    - name: Ensure required folders exist on the destination host
      ansible.builtin.file:
        path: "{{ item.split(':')[0] | dirname }}"
        state: directory
        mode: "0700"
      loop: "{{ mailrise_volumes }}"
      delegate_to: "{{ destination_host }}"
      when: item.split(':')[0] is string and item.split(':')[0] != item.split(':')[0] | dirname

    - name: Ensure the base directory for docker-compose output exists
      ansible.builtin.file:
        path: "{{ docker_compose_output | dirname }}"
        state: directory
        mode: "0755"
      delegate_to: "localhost"

    - name: Generate mailrise-compose.yaml from template
      ansible.builtin.template:
        src: "{{ docker_compose_template }}"
        dest: "{{ docker_compose_output }}"
        mode: "0644"
      delegate_to: "localhost"
      register: mailrise_compose_file

    - name: Ensure the base directory for MailRise output config exists
      ansible.builtin.file:
        path: "{{ mailrise_config_output | dirname }}"
        state: directory
        mode: "0755"
      delegate_to: "localhost"

    - name: Generate mailrise.conf from template
      ansible.builtin.template:
        src: "{{ mailrise_config_template }}"
        dest: "{{ mailrise_config_output }}"
        mode: "0644"
      delegate_to: "localhost"
      register: mailrise_config_parsed_template

    - name: Upload new MailRise config
      ansible.builtin.copy:
        src: "{{ mailrise_config_output }}"
        dest: "{{ mailrise_config_file }}"
        mode: "0644"
      delegate_to: "{{ destination_host }}"
      when: mailrise_config_parsed_template.changed

    - name: Generate signed certificate for MailRise
      ansible.builtin.command:
        cmd: >
          python scripts/generate-signed-certificate.py
          --base-path {{ certificate_tools_path }}
          --ca-alias {{ cluster_name }}
          --ca-cn "{{ cluster_name }} root ca"
          --signed-alias "{{ service_name }}"
          --signed-cn "{{ service_name }}.{{ cluster_domain }}"
          --signed-san-ip {{ hostvars[destination_host].ansible_host }}
          --output-format ansible
      register: signed_cert_output
      changed_when: (signed_cert_output.stdout | from_json).changed
      delegate_to: localhost

    - name: Parse output of signed certificate generation
      ansible.builtin.set_fact:
        ca_crt_path: "{{ (signed_cert_output.stdout | from_json).details['ca-crt-path'] }}"
        signed_crt_path: "{{ (signed_cert_output.stdout | from_json).details['signed-crt-path'] }}"
        signed_key_path: "{{ (signed_cert_output.stdout | from_json).details['signed-key-path'] }}"
      changed_when: false

    - name: Ensure CA certificate is copied to Proxmox
      ansible.builtin.copy:
        src: "{{ ca_crt_path }}"
        dest: "/usr/local/share/ca-certificates/{{ cluster_name }}_root_ca.crt"
        mode: "644"
      delegate_to: pve
      notify: Update trusted CAs

    - name: Copy certificates to MailRise
      ansible.builtin.copy:
        src: "{{ item.src }}"
        dest: "{{ item.dest }}"
        mode: "0644"
      loop:
        - { src: "{{ signed_crt_path }}", dest: "{{ mailrise_crt_file }}" }
        - { src: "{{ signed_key_path }}", dest: "{{ mailrise_key_file }}" }

    - name: Check if stack exists in Portainer
      ansible.builtin.uri:
        url: "{{ portainer_api_url }}/stacks?filters={\"EndpointId\":{{ endpoint_id }}}"
        method: GET
        headers:
          Authorization: "Bearer {{ portainer_api_token }}"
          Content-Type: "application/json"
        status_code: 200
      register: portainer_stacks_response

    - name: Find stack by name
      set_fact:
        portainer_stack_found: "{{ portainer_stacks_response.json | selectattr('Name', 'equalto', portainer_stack_name) | first }}"
      when: portainer_stacks_response.json | length > 0

    - name: Set fact if stack exists
      ansible.builtin.set_fact:
        stack_exists: "{{ portainer_stack_found is defined }}"

    - name: Stack already created
      ansible.builtin.debug:
        var: stack_exists

    - name: Deploy stack to Portainer (Create or Update)
      ansible.builtin.shell: |
        # Using curl instead of ansible.builtin.uri to ensure correct file uploads
        curl -X POST "{{ portainer_api_url_remote }}/stacks/create/standalone/file?endpointId={{ endpoint_id }}" \
          -H "Authorization: Bearer {{ portainer_api_token }}" \
          -F "Name={{ portainer_stack_name }}" \
          -F "Env=[{'CF_DNS_API_TOKEN':'{{ cloudflare_dns_api_token }}']" \
          -F "file=@{{ docker_compose_output }}" \
      delegate_to: localhost
      when: mailrise_compose_file.changed or not stack_exists
